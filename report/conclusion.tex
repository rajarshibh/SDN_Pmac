\section{Conclusion and Future Work}
\label{sec:conclusion}
In this paper, we presented a framework for programming a network of software defined radios using  software defined networking (SDN) principles. The framework we propose allows adaptive, flexible, and real-time (re)configuration of software defined radio interfaces from a network controller application. It streamlines the development of network applications by hiding the low level  internal details of the signal processing pipeline. In order to validate our approach, we also provide three proof-of-concept applications: \emph{frequency hopping}, \emph{adaptive modulation} and \emph{cognitive radio}. This shows that our design is viable and can be extended to introduce new capabilities.

One of the challenges that we need to consider is in-band control of the radio devices. Currently we implemented our design using an out-of-band wired control channel. The \crossflow framework can easily be extended to enable in-band control of devices and it will be our next design goal. Another area of focus is the latency between controller and SDR framework. The issue can be mitigated, by the introduction of distributed control module in SDR. The distributed control module will allow devices to take local decisions while the centralized controller is responsible for introducing policies and global management, thereby ensuring reduced latency.
The \crossflow framework can also be extended to allow controller to create other abstract radio blocks and manipulate inter-connections between those radio blocks. It requires design of new APIs on switch agent and can be implemented by combining the methodology provided by GNU Radio. In GNU radio, each block has an input and output port and the application needs to specify the connecting ports in order to connect the blocks. Only ports which are similar, i.e, ports which operate on same types of data(message or stream), can connect to each other. The data type supported by a block can be obtained by sending capability messages. The decision whether two ports are compatible can be left to the application. 
